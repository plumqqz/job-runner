Это микрофреймворк для обработки последовательности транзакций.  Каждая такая последовательность состоит из перечисления функций
или массива функций. Функции добавляются методом submit, который принимает функцию или массив функций
В дальнейшем эти функции будут выполнены последовательно (функции, перечисленные в массиве, переданном методу 
submit, могут быть выполненны параллельно, надо это иметь в виду), см. метод run ниэе, который, собственно,
и занимается вполнением по указанным правилам.

Если такая функция выбрасывает исключение, то выполнение всей цепочки прерывается, надо сходить в базу и снять
флаг is_failed с соответствующего шага джоба.
Если такая функция возвращает null/false, то она считается успешно выполенненой
Если такая функция возвращает не ложь,то она будет вызываться до тех пор, пока не вернет false
Если такая функция вернет массив с ключом [ 'run_after' => <number> ], то ее выполнение 
будет приостановлено на <number> секунд.


 Джоб идентифицируется именем. Имя должно быть уникальным среди всех джобов
 Для того, чтобы добавлять - даже не исполнять джобы - надо иметь их определения
 Таким образом, надо с джобами обращаться аккуратно
 джоб создается так:
 $job = new Job("JOB-NAME");

 Шаги добавляются так:
 $job->submit(function($param, &$ctx, $je){}) #1
     ->submit(function($param, &$ctx, $je){}) #2
    ->submit([function($param, &$ctx, $je){}, #3.1
              function($param, &$ctx, $je){}, #3.2
              .....
              function($param, &$ctx, $je){}  #3.n
             ])
     ->submit(function($param, &$ctx, $je){}) #4
При выполенении сначала будет выполнена функция 1 и если она завершится без ошибок и вернет null/false,
будет выполенена функция #2, далее функции 3.1,3.2 и т.д (возможно паралелльно), далее функция 4
Если функция возвращает положительное значение, то оно будет проинтерпретировано как задержка в секундах
для повторного вызова, и она будет вызвана еще раз.
Если фунция выбрасывает исключение, то транзакция откатывается, а job помечается как неудавшийся.
Если функция возвращает отрицательное значение, то job помечается как неудавшийся, но, в отличие
от случая с исключением, транзакция фиксируется. В дальнейщем такой job может быть возобновлен
с помощью метода resumeJob.
Если функция возвращает массив вида [ 'jobName', [ 'params', 'array'], [ 'ctx', 'array'], delay ], 
то будет создан новый job, а все шаги текущего джбоа будут зависеть от шагов нового.
Есть методы listEndedJobs, listNotEndedJobs, listFailedJobs, возвращающие список соответствующих задач.
Все они могут иметь параметр - маска имени (см. like из SQL).
Метод cleanUp() удаляет успешно завершившиеся задачи.


Все функции получают следующие параметры
  $param - параметры вызова джоба
  $ctx - контекст выполнения джоба. Он один на все функции. Его можно модифицировать,
  модификации видят все последующие функции, порядок модификации функций, переданных в массиве,
  и выполняющихся, таким образом, разумеется, не определен.
  JobExecutor $je - объект, выполняющий данный джоб. Может использоваться
   для постановки новых джобов на выполнение.
 
Выше создано описание джоба. Теперь его можно сохранить
в БД (в БД обязательно, т.к. необходима поддержка транзакций
для корректной работы).
ДЛя сохранения и выполнения джоба потребуется JobExecutor и соедиение
с БД. Создается он вполне стандартно:

$je = new JobExecutor($dbh);

Добавляем джоб в JobExecutor - это надо для возможности выполнить
метод execute, ему надо количество шагов и их типы; и, кроме того,
это надо методу run для собственно выполения.
Метод $je->execute("job-name", [ 'parameter1' => 'value', ...])
ставит джоб job-name с указанными параметрами на выполнение.
Если джоб с таким именем и такими же параметрами выполнялся ранее,
вызов будет проигнорирован.

$je->run()
бесконечно читает джобы из БД и выполняет их по шагам
     


Как это работает.
Пример:

<?php
include_once("job_manager.php");
#$dbh = new PDO('mysql:host=localhost;port=3306;dbname=jobs', 'root','');
$dbh = new PDO('pgsql:host=localhost;port=5433;dbname=work', 'postgres','root');
$je = new JobExecutor($dbh);
#$je->setDbh($dbh);

$job = new Job("RUN#1");
$job->submit(function($param, &$ctx){
                   $ctx['val']=1;
                   print "In #1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
             })
    ->submit([ function($param, &$ctx){
                   print "In #2.1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";        
                   if(!isset($ctx['val1']))
                     $ctx['val1']=0;
                   $ctx['val1']++;
                   if($ctx['val1']<40)
                        return [ 'run_after' => 1 ];
                   return null;
               },
               function($param, &$ctx, $je){
                   print "In #2.2 param[name]={$param['name']} ctx[valx]={$ctx['valx']}\n";
                   if(!isset($ctx['valx']))
                     $ctx['valx']=0;
                   $ctx['valx']++;
                   if($ctx['valx']==4){
                      $je->execute('sendmail', [ 'to' => 'lala@dodo.com', 'subject' => 'Just subject', 'body' => $param['name'] ]); 
                   }
                   $je->exec_query('insert into cnt(val) values(1)');
                   if($ctx['valx']<6){
                      return "CONTINUE";
                   }
               }
             ]
    )
    ->submit(function($param, &$ctx){
                   print "In #3 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
                   $ctx['val']++;
            });
$je->add($job);

$payoutJob = new Job("user-payout");
$payoutJob->submit( function($param, &$ctx, $je){
                             print "Payout to user {$param['to']}\n";
                    });
$je->add($payoutJob);

$sendMailJob = new Job('sendmail');
$sendMailJob->submit( function($param, &$ctx){
                          print "********************** Sending mail to {$param['to']}\n";
                          $ctx['sended']=true;
                    })
            ->submit( function($param, &$ctx, $je){
                      if($ctx['sended']){
                         print "########################### Sended!\n";
                      }
            });

$je->add($sendMailJob);

$je->execute("RUN#1", [ "path" => 1, "name"=>'Name'.time() . getmypid() ]);	
$je->run();

JobManager уже умеет выполнять одну стандартную задачу - .execute - выполнение указанной задачи.
Ее параметры - [ 'name' => 'job-name', 'param' => [ 'val1' => 1, .... ], 'ctx' => [ ... ], 'delay' => 0 ]
Зачем это может потребоваться? Например, затем, чтобы поставить выполняться задачу, не имея ее описания. Это
может делать, например, веб-приложение, запуская какую-то длительную операцию. Веб-приложению совершенно не нужно
знать, из каких шагов состоит эта операция - да даже лучше и не знать совсем, незачем. Для простоты предположим,
что веб-приложение должно осуществлять отправку уведомлений. Для отправки уведомления достаточно
вызвать метод execute объекта JobExecutor:
$je->execute('.execute', 'param' => ['name' => 'sendMessage', 'param' => [ 'to' => 'poupkine@mail.com' ] ]);

sendMessage, в свою очередь, может быть описан как:
$job = new Job('sendMessage');

$job->submit([
    function($param, &$ctx, $je){
        # send here email to $param['to']
    },
    function($param, &$ctx, $je){
        # semd here sms to $param['to']
    },
    ....
]);

