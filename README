Это микрофреймворк для обработки последовательности транзакций.  Каждая такая последовательность состоит из перечисления функций
или массива функций. Каждая такая функция или массив функций являются шагами заданий. Функции добавляются методом submit, 
который принимает функцию или массив функций. В дальнейшем эти функции будут выполнены последовательно 
(функции, перечисленные в массиве, переданном методу submit, могут быть выполненны параллельно, 
надо это иметь в виду), см. метод run ниже, который, собственно, и занимается вполнением по указанным правилам.

Задача идентифицируется именем. Имя должно быть уникальным среди всех задач.
Для того, чтобы добавлять - даже не исполнять задачи - надо иметь их определения
Задание создается так:

 $job = new Job("JOB-NAME");

 Шаги добавляются так:
 $job->submit(function($param, &$ctx, $je){}) #1
     ->submit(function($param, &$ctx, $je){}) #2
    ->submit([function($param, &$ctx, $je){}, #3.1
              function($param, &$ctx, $je){}, #3.2
              .....
              function($param, &$ctx, $je){}  #3.n
             ])
     ->submit(function($param, &$ctx, $je){}) #4

При выполенении сначала будет выполнена функция 1 и если она завершится без ошибок и вернет null/false,
будет выполенена функция #2, далее функции 3.1,3.2 и т.д (возможно паралелльно), далее функция 4
Если функция возвращает положительное значение, то оно будет проинтерпретировано как задержка в секундах
для повторного вызова, и она будет вызвана еще раз.
Если функция возвращает отрицательное значение, то шаг завершится, транзакция зафиксируется, выполнившийся шаг будет удален,
но сама задача будет помечена как неудавшаяся и дальнейшее выполнение задачи будет остановлена.
Если функция возвращает instanceof Exception, то и шаг задания, и само задание помечается, как неудавшееся, но транзакция фиксируется
Если функция возвращает строку DELETE, то задание удаляется целиком.
Если фунция выбрасывает исключение, то транзакция откатывается, а job помечается как неудавшийся.
Если функция возвращает массив вида [ 'jobName', [ 'params', 'array'], [ 'ctx', 'array'], delay ], 
то будет создан новый job, а все шаги текущего задания будут зависеть от шагов нового; таким образом,
выполнение текущего задания будет приостановлено до выполнения всех шагов указанного задания.
Разумеется, можно отправить задание на асинхронное выполнение обычным методом execute (см. ниже); следует,
однако, иметь в виду, что фактическое выполнение нового задания начнется только по окончанию создавшего.

Есть методы listEndedJobs, listNotEndedJobs, listFailedJobs, возвращающие список соответствующих задач.
Все они могут иметь параметр - маска имени (см. like из SQL).
Метод cleanUp() удаляет успешно завершившиеся задачи.

Все функции, представляющие шаги задания, получают следующие параметры:
  $param - параметры вызова задания
  $ctx - контекст выполнения задания. Он один на все шаги. Его можно модифицировать,
  модификации видят все последующие шаги, порядок модификации шаги, переданных в массиве,
  и выполняющихся, таким образом, разумеется, не определен.
  JobExecutor $je - объект, выполняющий данное задание. Может использоваться
   для постановки новых заданий на выполнение.
  $jobStep - массив, содержащий описание шага. Есть как минимум два индекса - id - идентификатор шага
    и job_id - идентификатор задачи
 
Выше создано описание задания. Теперь его можно сохранить
в БД (в БД обязательно, т.к. необходима поддержка транзакций
для корректной работы).
Для сохранения и выполнения задания потребуется JobExecutor и соедиение
с БД. Создается он вполне стандартно:

$je = new JobExecutor($dbh);

Добавляем задание в JobExecutor - это надо для возможности выполнить
метод execute, ему надо количество шагов и их типы; и, кроме того,
это надо методу run для собственно выполения.
Метод $je->execute("job-name", [ 'parameter1' => 'value', ...]);
ставит задание job-name с указанными параметрами на выполнение.
Если задание с таким именем и такими же параметрами выполнялся ранее,
вызов будет проигнорирован.
Дополнительно в методо execute могут быть переданы задержка выполнения в секундах
   $je->execute("job-name", [ 'parameter1' => 'value', ...], $delay);
и массив шагов, от которых будут зависеть первые шаги создаваемого задания (по умолчанию пустой)
   $je->execute("job-name", [ 'parameter1' => 'value', ...], 10, [ $jobStep['id'] ]);
 Таким образом, задание job-name будет выполнено, если текущий шаг будет успешно выполнен.
 (Предполагается, что метод execute вызывается из функции, переданной как параметр в submit.
   $je->execute("job-name", [ 'parameter1' => 'value', ...], 10, [ $je->getJobLastStepId($jobStep['id']) ]);
 Задание job-name будет выполнено, когда будет успешно выполнен последний шаг текущего задания
 (см. оговорку в предыдущем примере)



$je->run()
бесконечно читает джобы из БД и выполняет их по шагам
     


Как это работает.
Пример:

<?php
include_once("job_manager.php");
#$dbh = new PDO('mysql:host=localhost;port=3306;dbname=jobs', 'root','');
$dbh = new PDO('pgsql:host=localhost;port=5433;dbname=work', 'postgres','root');
$je = new JobExecutor($dbh);
#$je->setDbh($dbh);

$job = new Job("RUN#1");
$job->submit(function($param, &$ctx){
                   $ctx['val']=1;
                   print "In #1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
             })
    ->submit([ function($param, &$ctx){
                   print "In #2.1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";        
                   if(!isset($ctx['val1']))
                     $ctx['val1']=0;
                   $ctx['val1']++;
                   if($ctx['val1']<40)
                        return [ 'run_after' => 1 ];
                   return null;
               },
               function($param, &$ctx, $je){
                   print "In #2.2 param[name]={$param['name']} ctx[valx]={$ctx['valx']}\n";
                   if(!isset($ctx['valx']))
                     $ctx['valx']=0;
                   $ctx['valx']++;
                   if($ctx['valx']==4){
                      $je->execute('sendmail', [ 'to' => 'lala@dodo.com', 'subject' => 'Just subject', 'body' => $param['name'] ]); 
                   }
                   $je->exec_query('insert into cnt(val) values(1)');
                   if($ctx['valx']<6){
                      return "CONTINUE";
                   }
               }
             ]
    )
    ->submit(function($param, &$ctx){
                   print "In #3 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
                   $ctx['val']++;
            });
$je->add($job);

$payoutJob = new Job("user-payout");
$payoutJob->submit( function($param, &$ctx, $je){
                             print "Payout to user {$param['to']}\n";
                    });
$je->add($payoutJob);

$sendMailJob = new Job('sendmail');
$sendMailJob->submit( function($param, &$ctx){
                          print "********************** Sending mail to {$param['to']}\n";
                          $ctx['sended']=true;
                    })
            ->submit( function($param, &$ctx, $je){
                      if($ctx['sended']){
                         print "########################### Sended!\n";
                      }
            });

$je->add($sendMailJob);

$je->execute("RUN#1", [ "path" => 1, "name"=>'Name'.time() . getmypid() ]);	
$je->run();

JobManager уже умеет выполнять одну стандартную задачу - .execute - выполнение указанной задачи.
Ее параметры - [ 'name' => 'job-name', 'param' => [ 'val1' => 1, .... ], 'ctx' => [ ... ], 'delay' => 0 ]
Зачем это может потребоваться? Например, затем, чтобы поставить выполняться задачу, не имея ее описания. Это
может делать, например, веб-приложение, запуская какую-то длительную операцию. Веб-приложению совершенно не нужно
знать, из каких шагов состоит эта операция - да даже лучше и не знать совсем, незачем. Для простоты предположим,
что веб-приложение должно осуществлять отправку уведомлений. Для отправки уведомления достаточно
вызвать метод execute объекта JobExecutor:
$je->execute('.execute', 'param' => ['name' => 'sendMessage', 'param' => [ 'to' => 'poupkine@mail.com' ] ]);

sendMessage, в свою очередь, может быть описан как:
$job = new Job('sendMessage');

$job->submit([
    function($param, &$ctx, $je){
        # send here email to $param['to']
    },
    function($param, &$ctx, $je){
        # semd here sms to $param['to']
    },
    ....
]);

