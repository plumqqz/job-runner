Это микрофреймворк для обработки последовательности транзакций.  Каждая такая последовательность состоит из перечисления функций
или массива функций. Функции добавляются методом submit, который принимает функцию или массив функций
В дальнейшем эти функции будут выполнены последовательно (функции, перечисленные в массиве, переданном методу 
submit, могут быть выполненны параллельно, надо это иметь в виду), см. метод run ниэе, который, собственно,
и занимается вполнением по указанным правилам.

Если такая функция выбрасывает исключение, то выполнение всей цепочки прерывается, надо сходить в базу и снять
флаг is_failed с соответствующего шага джоба.
Если такая функция возвращает null/false, то она считается успешно выполенненой
Если такая функция возвращает не ложь,то она будет вызываться до тех пор, пока не вернет false


 Джоб идентифицируется именем. Имя должно быть уникальным среди всех джобов
 Для того, чтобы добавлять - даже не исполнять джобы - надо иметь их определения
 Таким образом, надо с джобами обращаться аккуратно
 джоб создается так:
 $job = new Job("JOB-NAME");

 Шаги добавляются так:
 $job->submit(function($param, &$ctx, $je){}) #1
     ->submit(function($param, &$ctx, $je){}) #2
    ->submit([function($param, &$ctx, $je){}, #3.1
              function($param, &$ctx, $je){}, #3.2
              .....
              function($param, &$ctx, $je){}  #3.n
             ])
     ->submit(function($param, &$ctx, $je){}) #4
 
Выше создано описание джоба. Теперь его можно сохранить
в БД (в БД обязательно, т.к. необходима поддержка транзакций
для корректной работы).
ДЛя сохранения и выполнения джоба потребуется JobExecutor и соедиение
с БД. Создается он вполне стандартно:

$je = new JobExecutor($dbh);

Добавляем джоб в JobExecutor - это надо для возможности выполнить
метод execute, ему надо количество шагов и их типы; и, кроме того,
это надо методу run для собственно выполения.
Метод $je->execute("job-name", [ 'parameter1' => 'value', ...])
ставит джоб job-name с указанными параметрами на выполнение.
Если джоб с таким именем и такими же параметрами выполнялся ранее,
вызов будет проигнорирован.
     


Как это работает.
Пример:

<?php
include_once("job_manager.php");
$dbh = new PDO('mysql:host=localhost;port=3306;dbname=jobs', 'root','');
$je = new JobExecutor();
# сначала надо установить соединение с базой, где живет репозитарий
# Репозитарий описывается в начале файла job_manager.php
#  в виде sql-скрипта.
$je->setDbh($dbh);

# Создаем джоб
# Джоб идентифицируется именем. Имя должно быть уникальным среди всех джобов
# Для того, чтобы добавлять - даже не исполнять джобы - надо иметь их определения
# Таким образом, надо с джобами обращаться аккуратно
$job = new Job("RUN#1");

# Добавляем в него функции
# Каждая функция получает три параметра - первые 
$job->submit(function($param, &$ctx, $je){
                   $ctx['val']=1;
                   print "In #1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
             })
    ->submit([ function($param, &$ctx){
                   print "In #2.1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";        
                   $ctx['val']++;
               },
               function($param, &$ctx){
                   print "In #2.2 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
                   $ctx['val']++;
                   if($ctx['val']<10){
                      return "CONTINUE";
                   }
               }
             ]
    )
    ->submit(function($param, &$ctx){
                   print "In #3 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
                   $ctx['val']++;
            });
# Добавляем в список доступных джобов. Надо следить, чтобы каждый логический джоб имел свое имя и 
# эти имена не конфликтовали
$je->add($job);

$je->execute("RUN#1", [ "path" => 1, "name"=>'Name'.time() ]);	
$je->run();

