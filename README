Это микрофреймворк для обработки последовательности транзакций.  Каждая такая последовательность состоит из перечисления функций
или массива функций. Каждая такая функция или массив функций являются шагами заданий. Функции добавляются методом submit, 
который принимает функцию или массив функций. В дальнейшем эти функции будут выполнены последовательно 
(функции, перечисленные в массиве, переданном методу submit, могут быть выполненны параллельно, 
надо это иметь в виду), см. метод run ниэе, который, собственно, и занимается вполнением по указанным правилам.

Задача идентифицируется именем. Имя должно быть уникальным среди всех задач.
Для того, чтобы добавлять - даже не исполнять задачи - надо иметь их определения
Задание создается так:

 $job = new Job("JOB-NAME");

 Шаги добавляются так:
 $job->submit(function($param, &$ctx, $je){}) #1
     ->submit(function($param, &$ctx, $je){}) #2
    ->submit([function($param, &$ctx, $je){}, #3.1
              function($param, &$ctx, $je){}, #3.2
              .....
              function($param, &$ctx, $je){}  #3.n
             ])
     ->submit(function($param, &$ctx, $je){}) #4

При выполенении сначала будет выполнена функция 1 и если она завершится без ошибок и вернет null/false,
будет выполенена функция #2, далее функции 3.1,3.2 и т.д (возможно паралелльно), далее функция 4
Если функция возвращает положительное значение, то оно будет проинтерпретировано как задержка в секундах
для повторного вызова, и она будет вызвана еще раз.
Если фунция выбрасывает исключение, то транзакция откатывается, а job помечается как неудавшийся.
Если функция возвращает массив вида [ 'jobName', [ 'params', 'array'], [ 'ctx', 'array'], delay ], 
то будет создан новый job, а все шаги текущего задания будут зависеть от шагов нового; таким образом,
выполнение текущего задания будет приостановлено до выполнения всех шагов указанного задания.
Разумеется, можно отправить задание на асинхронное выполнение обычным методом execute (см. ниже).

Есть методы listEndedJobs, listNotEndedJobs, listFailedJobs, возвращающие список соответствующих задач.
Все они могут иметь параметр - маска имени (см. like из SQL).
Метод cleanUp() удаляет успешно завершившиеся задачи.

Если такая функция выбрасывает исключение, то выполнение всей цепочки прерывается, надо сходить в базу и снять
флаг is_failed с соответствующего шага джоба.

Если такая функция возвращает null/false, то шаг джоба считается успешно выполенненой

Если функция возвращает отрицательное значение, то job помечается как неудавшийся, но, в отличие
от случая с исключением, транзакция фиксируется. В дальнейщем такой job может быть возобновлен
с помощью метода resumeJob.

Если такая функция возвращает не ложь и не число,то она будет вызываться до тех пор, пока не вернет false.

Если функция возвращает массив вида [ 'jobName', [ 'params', 'array'], [ 'ctx', 'array'], delay ], 
то будет создан новый job с соответствующим именем, а все шаги текущего джбоа будут зависеть от шагов нового.


Все функции, представляющие шаги задания, получают следующие параметры:
  $param - параметры вызова задания
  $ctx - контекст выполнения задания. Он один на все функции. Его можно модифицировать,
  модификации видят все последующие функции, порядок модификации функций, переданных в массиве,
  и выполняющихся, таким образом, разумеется, не определен.
  JobExecutor $je - объект, выполняющий данное задание. Может использоваться
   для постановки новых заданий на выполнение.
 
Выше создано описание задания. Теперь его можно сохранить
в БД (в БД обязательно, т.к. необходима поддержка транзакций
для корректной работы).
Для сохранения и выполнения задания потребуется JobExecutor и соедиение
с БД. Создается он вполне стандартно:

$je = new JobExecutor($dbh);

Добавляем задание в JobExecutor - это надо для возможности выполнить
метод execute, ему надо количество шагов и их типы; и, кроме того,
это надо методу run для собственно выполения.
Метод $je->execute("job-name", [ 'parameter1' => 'value', ...])
ставит задание job-name с указанными параметрами на выполнение.
Если задание с таким именем и такими же параметрами выполнялся ранее,
вызов будет проигнорирован.

$je->run()
бесконечно читает джобы из БД и выполняет их по шагам
     


Как это работает.
Пример:

<?php
include_once("job_manager.php");
#$dbh = new PDO('mysql:host=localhost;port=3306;dbname=jobs', 'root','');
$dbh = new PDO('pgsql:host=localhost;port=5433;dbname=work', 'postgres','root');
$je = new JobExecutor($dbh);
#$je->setDbh($dbh);

$job = new Job("RUN#1");
$job->submit(function($param, &$ctx){
                   $ctx['val']=1;
                   print "In #1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
             })
    ->submit([ function($param, &$ctx){
                   print "In #2.1 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";        
                   if(!isset($ctx['val1']))
                     $ctx['val1']=0;
                   $ctx['val1']++;
                   if($ctx['val1']<40)
                        return [ 'run_after' => 1 ];
                   return null;
               },
               function($param, &$ctx, $je){
                   print "In #2.2 param[name]={$param['name']} ctx[valx]={$ctx['valx']}\n";
                   if(!isset($ctx['valx']))
                     $ctx['valx']=0;
                   $ctx['valx']++;
                   if($ctx['valx']==4){
                      $je->execute('sendmail', [ 'to' => 'lala@dodo.com', 'subject' => 'Just subject', 'body' => $param['name'] ]); 
                   }
                   $je->exec_query('insert into cnt(val) values(1)');
                   if($ctx['valx']<6){
                      return "CONTINUE";
                   }
               }
             ]
    )
    ->submit(function($param, &$ctx){
                   print "In #3 param[name]={$param['name']} ctx[val]={$ctx['val']}\n";
                   $ctx['val']++;
            });
$je->add($job);

$payoutJob = new Job("user-payout");
$payoutJob->submit( function($param, &$ctx, $je){
                             print "Payout to user {$param['to']}\n";
                    });
$je->add($payoutJob);

$sendMailJob = new Job('sendmail');
$sendMailJob->submit( function($param, &$ctx){
                          print "********************** Sending mail to {$param['to']}\n";
                          $ctx['sended']=true;
                    })
            ->submit( function($param, &$ctx, $je){
                      if($ctx['sended']){
                         print "########################### Sended!\n";
                      }
            });

$je->add($sendMailJob);

$je->execute("RUN#1", [ "path" => 1, "name"=>'Name'.time() . getmypid() ]);	
$je->run();

JobManager уже умеет выполнять одну стандартную задачу - .execute - выполнение указанной задачи.
Ее параметры - [ 'name' => 'job-name', 'param' => [ 'val1' => 1, .... ], 'ctx' => [ ... ], 'delay' => 0 ]
Зачем это может потребоваться? Например, затем, чтобы поставить выполняться задачу, не имея ее описания. Это
может делать, например, веб-приложение, запуская какую-то длительную операцию. Веб-приложению совершенно не нужно
знать, из каких шагов состоит эта операция - да даже лучше и не знать совсем, незачем. Для простоты предположим,
что веб-приложение должно осуществлять отправку уведомлений. Для отправки уведомления достаточно
вызвать метод execute объекта JobExecutor:
$je->execute('.execute', 'param' => ['name' => 'sendMessage', 'param' => [ 'to' => 'poupkine@mail.com' ] ]);

sendMessage, в свою очередь, может быть описан как:
$job = new Job('sendMessage');

$job->submit([
    function($param, &$ctx, $je){
        # send here email to $param['to']
    },
    function($param, &$ctx, $je){
        # semd here sms to $param['to']
    },
    ....
]);

